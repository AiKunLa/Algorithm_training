# 回溯算法-递归思想（终结条件和处理逻辑）
## 解决的问题
- 组合问题
 eg: 1234  组合为 12  13  14  23  24  34
- 切割问题 
 eg: 1234  切割为 1 2 3 4  12 13 14 23 24 34  123 124 134 234  1234
- 子集问题
 eg: 1234  子集为 1 2 3 4  12 13 14 23 24 34  123 124 134 234  1234
- 排列问题 - 元素的顺序
 eg: 
- 棋盘问题 - N皇后 数独

## 主要思想
for循环横向遍历，递归纵向遍历，回溯不断调整结果集

递归函数一般没有返回值 
void back(){
    if(终止条件){
        存放结果;
        return;
    }
    for(遍历集合){
        // 剪枝
        if(剪枝条件)break;
        处理节点; 
        back();// 递归
        回溯; // 回溯的过程，撤销处理结果
    }
    return;
}

## 递归
- 自顶向下——树型结构
- 问题可以拆分为树状结构
- 有退出条件，当问题可以被拆分为多个子问题的时候
- 什么时候使用递归
    - 当问题的规模不断减小的时候
- 什么时候不使用递归
    - 当问题的规模不断增大的时候
    - 当问题的空间复杂度不断增大的时候
- 递归的问题
 - 重复计算 —— 使用记忆的方法来解决 —— js中使用闭包来计算
 - 栈溢出 —— 函数执行时需要调用栈 执行上下文 、作用域、变量环境、词法环境、outer维护作用域链

 ## 去重 
 ### 树层去重
对于组合问题，需要对数组进行排序，然后在for循环中进行去重
如果当前元素和前一个元素相同，则跳过当前元素，因为前一个元素已经在当前层中被处理过了。

 ### 树枝去重
对于排列问题，每次都需要从头开始遍历，不能使用树层去重的方法。
使用used数组来记录每个元素是否被使用过，每次递归时都需要判断当前元素是否被使用过。
如果当前元素未被使用过，则将其标记为已使用，并将其加入当前组合中。
然后递归调用下一层，继续搜索未被使用过的元素。
在回溯时，需要将当前元素标记为未使用，并将其从当前组合中移除。
- 去重代码
```js
function backtrack(nums, used, path, res) {
    if (path.length === nums.length) {
        res.push([...path]);
        return;
    }
    for (let i = 0; i < nums.length; i++) {
        if (used[i]) continue;
